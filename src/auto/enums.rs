// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use glib::error::ErrorDomain;
use glib::translate::*;
use glib::value::FromValue;
use glib::value::FromValueOptional;
use glib::value::SetValue;
use glib::value::Value;
use glib::Quark;
use glib::StaticType;
use glib::Type;
use gobject_sys;
use ibus_sys;
use std::fmt;

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum AttrType {
    Underline,
    Foreground,
    Background,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for AttrType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "AttrType::{}", match *self {
            AttrType::Underline => "Underline",
            AttrType::Foreground => "Foreground",
            AttrType::Background => "Background",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for AttrType {
    type GlibType = ibus_sys::IBusAttrType;

    fn to_glib(&self) -> ibus_sys::IBusAttrType {
        match *self {
            AttrType::Underline => ibus_sys::IBUS_ATTR_TYPE_UNDERLINE,
            AttrType::Foreground => ibus_sys::IBUS_ATTR_TYPE_FOREGROUND,
            AttrType::Background => ibus_sys::IBUS_ATTR_TYPE_BACKGROUND,
            AttrType::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ibus_sys::IBusAttrType> for AttrType {
    fn from_glib(value: ibus_sys::IBusAttrType) -> Self {
        skip_assert_initialized!();
        match value {
            1 => AttrType::Underline,
            2 => AttrType::Foreground,
            3 => AttrType::Background,
            value => AttrType::__Unknown(value),
        }
    }
}

impl StaticType for AttrType {
    fn static_type() -> Type {
        unsafe { from_glib(ibus_sys::ibus_attr_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for AttrType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for AttrType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for AttrType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum AttrUnderline {
    None,
    Single,
    Double,
    Low,
    Error,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for AttrUnderline {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "AttrUnderline::{}", match *self {
            AttrUnderline::None => "None",
            AttrUnderline::Single => "Single",
            AttrUnderline::Double => "Double",
            AttrUnderline::Low => "Low",
            AttrUnderline::Error => "Error",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for AttrUnderline {
    type GlibType = ibus_sys::IBusAttrUnderline;

    fn to_glib(&self) -> ibus_sys::IBusAttrUnderline {
        match *self {
            AttrUnderline::None => ibus_sys::IBUS_ATTR_UNDERLINE_NONE,
            AttrUnderline::Single => ibus_sys::IBUS_ATTR_UNDERLINE_SINGLE,
            AttrUnderline::Double => ibus_sys::IBUS_ATTR_UNDERLINE_DOUBLE,
            AttrUnderline::Low => ibus_sys::IBUS_ATTR_UNDERLINE_LOW,
            AttrUnderline::Error => ibus_sys::IBUS_ATTR_UNDERLINE_ERROR,
            AttrUnderline::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ibus_sys::IBusAttrUnderline> for AttrUnderline {
    fn from_glib(value: ibus_sys::IBusAttrUnderline) -> Self {
        skip_assert_initialized!();
        match value {
            0 => AttrUnderline::None,
            1 => AttrUnderline::Single,
            2 => AttrUnderline::Double,
            3 => AttrUnderline::Low,
            4 => AttrUnderline::Error,
            value => AttrUnderline::__Unknown(value),
        }
    }
}

impl StaticType for AttrUnderline {
    fn static_type() -> Type {
        unsafe { from_glib(ibus_sys::ibus_attr_underline_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for AttrUnderline {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for AttrUnderline {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for AttrUnderline {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum BusRequestNameReply {
    PrimaryOwner,
    InQueue,
    Exists,
    AlreadyOwner,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for BusRequestNameReply {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "BusRequestNameReply::{}", match *self {
            BusRequestNameReply::PrimaryOwner => "PrimaryOwner",
            BusRequestNameReply::InQueue => "InQueue",
            BusRequestNameReply::Exists => "Exists",
            BusRequestNameReply::AlreadyOwner => "AlreadyOwner",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for BusRequestNameReply {
    type GlibType = ibus_sys::IBusBusRequestNameReply;

    fn to_glib(&self) -> ibus_sys::IBusBusRequestNameReply {
        match *self {
            BusRequestNameReply::PrimaryOwner => ibus_sys::IBUS_BUS_REQUEST_NAME_REPLY_PRIMARY_OWNER,
            BusRequestNameReply::InQueue => ibus_sys::IBUS_BUS_REQUEST_NAME_REPLY_IN_QUEUE,
            BusRequestNameReply::Exists => ibus_sys::IBUS_BUS_REQUEST_NAME_REPLY_EXISTS,
            BusRequestNameReply::AlreadyOwner => ibus_sys::IBUS_BUS_REQUEST_NAME_REPLY_ALREADY_OWNER,
            BusRequestNameReply::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ibus_sys::IBusBusRequestNameReply> for BusRequestNameReply {
    fn from_glib(value: ibus_sys::IBusBusRequestNameReply) -> Self {
        skip_assert_initialized!();
        match value {
            1 => BusRequestNameReply::PrimaryOwner,
            2 => BusRequestNameReply::InQueue,
            3 => BusRequestNameReply::Exists,
            4 => BusRequestNameReply::AlreadyOwner,
            value => BusRequestNameReply::__Unknown(value),
        }
    }
}

impl StaticType for BusRequestNameReply {
    fn static_type() -> Type {
        unsafe { from_glib(ibus_sys::ibus_bus_request_name_reply_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for BusRequestNameReply {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for BusRequestNameReply {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for BusRequestNameReply {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum BusStartServiceByNameReply {
    Success,
    AlreadyRunning,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for BusStartServiceByNameReply {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "BusStartServiceByNameReply::{}", match *self {
            BusStartServiceByNameReply::Success => "Success",
            BusStartServiceByNameReply::AlreadyRunning => "AlreadyRunning",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for BusStartServiceByNameReply {
    type GlibType = ibus_sys::IBusBusStartServiceByNameReply;

    fn to_glib(&self) -> ibus_sys::IBusBusStartServiceByNameReply {
        match *self {
            BusStartServiceByNameReply::Success => ibus_sys::IBUS_BUS_START_REPLY_SUCCESS,
            BusStartServiceByNameReply::AlreadyRunning => ibus_sys::IBUS_BUS_START_REPLY_ALREADY_RUNNING,
            BusStartServiceByNameReply::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ibus_sys::IBusBusStartServiceByNameReply> for BusStartServiceByNameReply {
    fn from_glib(value: ibus_sys::IBusBusStartServiceByNameReply) -> Self {
        skip_assert_initialized!();
        match value {
            1 => BusStartServiceByNameReply::Success,
            2 => BusStartServiceByNameReply::AlreadyRunning,
            value => BusStartServiceByNameReply::__Unknown(value),
        }
    }
}

impl StaticType for BusStartServiceByNameReply {
    fn static_type() -> Type {
        unsafe { from_glib(ibus_sys::ibus_bus_start_service_by_name_reply_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for BusStartServiceByNameReply {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for BusStartServiceByNameReply {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for BusStartServiceByNameReply {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum Error {
    NoEngine,
    NoConfig,
    Failed,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Error::{}", match *self {
            Error::NoEngine => "NoEngine",
            Error::NoConfig => "NoConfig",
            Error::Failed => "Failed",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for Error {
    type GlibType = ibus_sys::IBusError;

    fn to_glib(&self) -> ibus_sys::IBusError {
        match *self {
            Error::NoEngine => ibus_sys::IBUS_ERROR_NO_ENGINE,
            Error::NoConfig => ibus_sys::IBUS_ERROR_NO_CONFIG,
            Error::Failed => ibus_sys::IBUS_ERROR_FAILED,
            Error::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ibus_sys::IBusError> for Error {
    fn from_glib(value: ibus_sys::IBusError) -> Self {
        skip_assert_initialized!();
        match value {
            0 => Error::NoEngine,
            1 => Error::NoConfig,
            2 => Error::Failed,
            value => Error::__Unknown(value),
        }
    }
}

impl ErrorDomain for Error {
    fn domain() -> Quark {
        skip_assert_initialized!();
        
        unsafe { from_glib(ibus_sys::ibus_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            0 => Some(Error::NoEngine),
            1 => Some(Error::NoConfig),
            2 => Some(Error::Failed),
            _ => Some(Error::Failed),
        }
    }
}

impl StaticType for Error {
    fn static_type() -> Type {
        unsafe { from_glib(ibus_sys::ibus_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for Error {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for Error {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for Error {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum InputPurpose {
    FreeForm,
    Alpha,
    Digits,
    Number,
    Phone,
    Url,
    Email,
    Name,
    Password,
    Pin,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for InputPurpose {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "InputPurpose::{}", match *self {
            InputPurpose::FreeForm => "FreeForm",
            InputPurpose::Alpha => "Alpha",
            InputPurpose::Digits => "Digits",
            InputPurpose::Number => "Number",
            InputPurpose::Phone => "Phone",
            InputPurpose::Url => "Url",
            InputPurpose::Email => "Email",
            InputPurpose::Name => "Name",
            InputPurpose::Password => "Password",
            InputPurpose::Pin => "Pin",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for InputPurpose {
    type GlibType = ibus_sys::IBusInputPurpose;

    fn to_glib(&self) -> ibus_sys::IBusInputPurpose {
        match *self {
            InputPurpose::FreeForm => ibus_sys::IBUS_INPUT_PURPOSE_FREE_FORM,
            InputPurpose::Alpha => ibus_sys::IBUS_INPUT_PURPOSE_ALPHA,
            InputPurpose::Digits => ibus_sys::IBUS_INPUT_PURPOSE_DIGITS,
            InputPurpose::Number => ibus_sys::IBUS_INPUT_PURPOSE_NUMBER,
            InputPurpose::Phone => ibus_sys::IBUS_INPUT_PURPOSE_PHONE,
            InputPurpose::Url => ibus_sys::IBUS_INPUT_PURPOSE_URL,
            InputPurpose::Email => ibus_sys::IBUS_INPUT_PURPOSE_EMAIL,
            InputPurpose::Name => ibus_sys::IBUS_INPUT_PURPOSE_NAME,
            InputPurpose::Password => ibus_sys::IBUS_INPUT_PURPOSE_PASSWORD,
            InputPurpose::Pin => ibus_sys::IBUS_INPUT_PURPOSE_PIN,
            InputPurpose::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ibus_sys::IBusInputPurpose> for InputPurpose {
    fn from_glib(value: ibus_sys::IBusInputPurpose) -> Self {
        skip_assert_initialized!();
        match value {
            0 => InputPurpose::FreeForm,
            1 => InputPurpose::Alpha,
            2 => InputPurpose::Digits,
            3 => InputPurpose::Number,
            4 => InputPurpose::Phone,
            5 => InputPurpose::Url,
            6 => InputPurpose::Email,
            7 => InputPurpose::Name,
            8 => InputPurpose::Password,
            9 => InputPurpose::Pin,
            value => InputPurpose::__Unknown(value),
        }
    }
}

impl StaticType for InputPurpose {
    fn static_type() -> Type {
        unsafe { from_glib(ibus_sys::ibus_input_purpose_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for InputPurpose {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for InputPurpose {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for InputPurpose {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum Orientation {
    Horizontal,
    Vertical,
    System,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for Orientation {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Orientation::{}", match *self {
            Orientation::Horizontal => "Horizontal",
            Orientation::Vertical => "Vertical",
            Orientation::System => "System",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for Orientation {
    type GlibType = ibus_sys::IBusOrientation;

    fn to_glib(&self) -> ibus_sys::IBusOrientation {
        match *self {
            Orientation::Horizontal => ibus_sys::IBUS_ORIENTATION_HORIZONTAL,
            Orientation::Vertical => ibus_sys::IBUS_ORIENTATION_VERTICAL,
            Orientation::System => ibus_sys::IBUS_ORIENTATION_SYSTEM,
            Orientation::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ibus_sys::IBusOrientation> for Orientation {
    fn from_glib(value: ibus_sys::IBusOrientation) -> Self {
        skip_assert_initialized!();
        match value {
            0 => Orientation::Horizontal,
            1 => Orientation::Vertical,
            2 => Orientation::System,
            value => Orientation::__Unknown(value),
        }
    }
}

impl StaticType for Orientation {
    fn static_type() -> Type {
        unsafe { from_glib(ibus_sys::ibus_orientation_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for Orientation {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for Orientation {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for Orientation {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum PreeditFocusMode {
    Clear,
    Commit,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PreeditFocusMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "PreeditFocusMode::{}", match *self {
            PreeditFocusMode::Clear => "Clear",
            PreeditFocusMode::Commit => "Commit",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for PreeditFocusMode {
    type GlibType = ibus_sys::IBusPreeditFocusMode;

    fn to_glib(&self) -> ibus_sys::IBusPreeditFocusMode {
        match *self {
            PreeditFocusMode::Clear => ibus_sys::IBUS_ENGINE_PREEDIT_CLEAR,
            PreeditFocusMode::Commit => ibus_sys::IBUS_ENGINE_PREEDIT_COMMIT,
            PreeditFocusMode::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ibus_sys::IBusPreeditFocusMode> for PreeditFocusMode {
    fn from_glib(value: ibus_sys::IBusPreeditFocusMode) -> Self {
        skip_assert_initialized!();
        match value {
            0 => PreeditFocusMode::Clear,
            1 => PreeditFocusMode::Commit,
            value => PreeditFocusMode::__Unknown(value),
        }
    }
}

impl StaticType for PreeditFocusMode {
    fn static_type() -> Type {
        unsafe { from_glib(ibus_sys::ibus_preedit_focus_mode_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PreeditFocusMode {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PreeditFocusMode {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PreeditFocusMode {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum PropState {
    Unchecked,
    Checked,
    Inconsistent,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PropState {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "PropState::{}", match *self {
            PropState::Unchecked => "Unchecked",
            PropState::Checked => "Checked",
            PropState::Inconsistent => "Inconsistent",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for PropState {
    type GlibType = ibus_sys::IBusPropState;

    fn to_glib(&self) -> ibus_sys::IBusPropState {
        match *self {
            PropState::Unchecked => ibus_sys::PROP_STATE_UNCHECKED,
            PropState::Checked => ibus_sys::PROP_STATE_CHECKED,
            PropState::Inconsistent => ibus_sys::PROP_STATE_INCONSISTENT,
            PropState::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ibus_sys::IBusPropState> for PropState {
    fn from_glib(value: ibus_sys::IBusPropState) -> Self {
        skip_assert_initialized!();
        match value {
            0 => PropState::Unchecked,
            1 => PropState::Checked,
            2 => PropState::Inconsistent,
            value => PropState::__Unknown(value),
        }
    }
}

impl StaticType for PropState {
    fn static_type() -> Type {
        unsafe { from_glib(ibus_sys::ibus_prop_state_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PropState {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PropState {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PropState {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum PropType {
    Normal,
    Toggle,
    Radio,
    Menu,
    Separator,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PropType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "PropType::{}", match *self {
            PropType::Normal => "Normal",
            PropType::Toggle => "Toggle",
            PropType::Radio => "Radio",
            PropType::Menu => "Menu",
            PropType::Separator => "Separator",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for PropType {
    type GlibType = ibus_sys::IBusPropType;

    fn to_glib(&self) -> ibus_sys::IBusPropType {
        match *self {
            PropType::Normal => ibus_sys::PROP_TYPE_NORMAL,
            PropType::Toggle => ibus_sys::PROP_TYPE_TOGGLE,
            PropType::Radio => ibus_sys::PROP_TYPE_RADIO,
            PropType::Menu => ibus_sys::PROP_TYPE_MENU,
            PropType::Separator => ibus_sys::PROP_TYPE_SEPARATOR,
            PropType::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ibus_sys::IBusPropType> for PropType {
    fn from_glib(value: ibus_sys::IBusPropType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => PropType::Normal,
            1 => PropType::Toggle,
            2 => PropType::Radio,
            3 => PropType::Menu,
            4 => PropType::Separator,
            value => PropType::__Unknown(value),
        }
    }
}

impl StaticType for PropType {
    fn static_type() -> Type {
        unsafe { from_glib(ibus_sys::ibus_prop_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for PropType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for PropType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for PropType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
pub enum XEventType {
    Nothing,
    KeyPress,
    KeyRelease,
    Other,
    EventLast,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for XEventType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "XEventType::{}", match *self {
            XEventType::Nothing => "Nothing",
            XEventType::KeyPress => "KeyPress",
            XEventType::KeyRelease => "KeyRelease",
            XEventType::Other => "Other",
            XEventType::EventLast => "EventLast",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for XEventType {
    type GlibType = ibus_sys::IBusXEventType;

    fn to_glib(&self) -> ibus_sys::IBusXEventType {
        match *self {
            XEventType::Nothing => ibus_sys::IBUS_X_EVENT_NOTHING,
            XEventType::KeyPress => ibus_sys::IBUS_X_EVENT_KEY_PRESS,
            XEventType::KeyRelease => ibus_sys::IBUS_X_EVENT_KEY_RELEASE,
            XEventType::Other => ibus_sys::IBUS_X_EVENT_OTHER,
            XEventType::EventLast => ibus_sys::IBUS_X_EVENT_EVENT_LAST,
            XEventType::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ibus_sys::IBusXEventType> for XEventType {
    fn from_glib(value: ibus_sys::IBusXEventType) -> Self {
        skip_assert_initialized!();
        match value {
            -1 => XEventType::Nothing,
            0 => XEventType::KeyPress,
            1 => XEventType::KeyRelease,
            2 => XEventType::Other,
            3 => XEventType::EventLast,
            value => XEventType::__Unknown(value),
        }
    }
}

impl StaticType for XEventType {
    fn static_type() -> Type {
        unsafe { from_glib(ibus_sys::ibus_xevent_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for XEventType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for XEventType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for XEventType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

