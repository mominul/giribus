// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use gio;
use glib::object::IsA;
use glib::translate::*;
use ibus_sys;
use std::fmt;
use Proxy;

glib_wrapper! {
    pub struct Config(Object<ibus_sys::IBusConfig, ibus_sys::IBusConfigClass, ConfigClass>) @extends Proxy, gio::DBusProxy, @implements gio::AsyncInitable, gio::DBusInterface, gio::Initable;

    match fn {
        get_type => || ibus_sys::ibus_config_get_type(),
    }
}

impl Config {
    //pub fn new<P: IsA<gio::Cancellable>>(connection: &gio::DBusConnection, cancellable: Option<&P>, error: /*Ignored*/Option<glib::Error>) -> Config {
    //    unsafe { TODO: call ibus_sys:ibus_config_new() }
    //}

    //pub fn new_async<P: IsA<gio::Cancellable>, Q: FnOnce(Result<(), glib::Error>) + 'static>(connection: &gio::DBusConnection, cancellable: Option<&P>, callback: Q) {
    //    unsafe { TODO: call ibus_sys:ibus_config_new_async() }
    //}
}

pub const NONE_CONFIG: Option<&Config> = None;

pub trait ConfigExt: 'static {
    //fn get_value(&self, section: &str, name: &str) -> /*Ignored*/Option<glib::Variant>;

    //fn get_value_async<P: IsA<gio::Cancellable>, Q: FnOnce(Result<(), glib::Error>) + 'static>(&self, section: &str, name: &str, timeout_ms: i32, cancellable: Option<&P>, callback: Q);

    //fn get_values(&self, section: &str) -> /*Ignored*/Option<glib::Variant>;

    //fn get_values_async<P: IsA<gio::Cancellable>, Q: FnOnce(Result<(), glib::Error>) + 'static>(&self, section: &str, timeout_ms: i32, cancellable: Option<&P>, callback: Q);

    //fn set_value(&self, section: &str, name: &str, value: /*Ignored*/&glib::Variant) -> bool;

    //fn set_value_async<P: IsA<gio::Cancellable>, Q: FnOnce(Result<(), glib::Error>) + 'static>(&self, section: &str, name: &str, value: /*Ignored*/&glib::Variant, timeout_ms: i32, cancellable: Option<&P>, callback: Q);

    fn unset(&self, section: &str, name: &str) -> bool;

    fn unwatch(&self, section: Option<&str>, name: Option<&str>) -> bool;

    fn watch(&self, section: Option<&str>, name: Option<&str>) -> bool;

    //fn connect_value_changed<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId;
}

impl<O: IsA<Config>> ConfigExt for O {
    //fn get_value(&self, section: &str, name: &str) -> /*Ignored*/Option<glib::Variant> {
    //    unsafe { TODO: call ibus_sys:ibus_config_get_value() }
    //}

    //fn get_value_async<P: IsA<gio::Cancellable>, Q: FnOnce(Result<(), glib::Error>) + 'static>(&self, section: &str, name: &str, timeout_ms: i32, cancellable: Option<&P>, callback: Q) {
    //    unsafe { TODO: call ibus_sys:ibus_config_get_value_async() }
    //}

    //fn get_values(&self, section: &str) -> /*Ignored*/Option<glib::Variant> {
    //    unsafe { TODO: call ibus_sys:ibus_config_get_values() }
    //}

    //fn get_values_async<P: IsA<gio::Cancellable>, Q: FnOnce(Result<(), glib::Error>) + 'static>(&self, section: &str, timeout_ms: i32, cancellable: Option<&P>, callback: Q) {
    //    unsafe { TODO: call ibus_sys:ibus_config_get_values_async() }
    //}

    //fn set_value(&self, section: &str, name: &str, value: /*Ignored*/&glib::Variant) -> bool {
    //    unsafe { TODO: call ibus_sys:ibus_config_set_value() }
    //}

    //fn set_value_async<P: IsA<gio::Cancellable>, Q: FnOnce(Result<(), glib::Error>) + 'static>(&self, section: &str, name: &str, value: /*Ignored*/&glib::Variant, timeout_ms: i32, cancellable: Option<&P>, callback: Q) {
    //    unsafe { TODO: call ibus_sys:ibus_config_set_value_async() }
    //}

    fn unset(&self, section: &str, name: &str) -> bool {
        unsafe {
            from_glib(ibus_sys::ibus_config_unset(self.as_ref().to_glib_none().0, section.to_glib_none().0, name.to_glib_none().0))
        }
    }

    fn unwatch(&self, section: Option<&str>, name: Option<&str>) -> bool {
        unsafe {
            from_glib(ibus_sys::ibus_config_unwatch(self.as_ref().to_glib_none().0, section.to_glib_none().0, name.to_glib_none().0))
        }
    }

    fn watch(&self, section: Option<&str>, name: Option<&str>) -> bool {
        unsafe {
            from_glib(ibus_sys::ibus_config_watch(self.as_ref().to_glib_none().0, section.to_glib_none().0, name.to_glib_none().0))
        }
    }

    //fn connect_value_changed<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Ignored value: GLib.Variant
    //}
}

impl fmt::Display for Config {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Config")
    }
}
