// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use gio;
use glib::object::Cast;
use glib::object::IsA;
use glib::signal::connect_raw;
use glib::signal::SignalHandlerId;
use glib::translate::*;
use glib_sys;
use ibus_sys;
use libc;
use std::boxed::Box as Box_;
use std::fmt;
use std::mem::transmute;
use EngineDesc;
use LookupTable;
use PropList;
use Property;
use Proxy;
use Text;

glib_wrapper! {
    pub struct InputContext(Object<ibus_sys::IBusInputContext, ibus_sys::IBusInputContextClass, InputContextClass>) @extends Proxy, gio::DBusProxy, @implements gio::AsyncInitable, gio::DBusInterface, gio::Initable;

    match fn {
        get_type => || ibus_sys::ibus_input_context_get_type(),
    }
}

impl InputContext {
    //pub fn new<P: IsA<gio::Cancellable>>(path: &str, connection: &gio::DBusConnection, cancellable: Option<&P>, error: /*Ignored*/Option<glib::Error>) -> InputContext {
    //    unsafe { TODO: call ibus_sys:ibus_input_context_new() }
    //}

    pub fn get_input_context(path: &str, connection: &gio::DBusConnection) -> Option<InputContext> {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(ibus_sys::ibus_input_context_get_input_context(path.to_glib_none().0, connection.to_glib_none().0))
        }
    }

    //pub fn get_input_context_async<P: IsA<gio::Cancellable>, Q: FnOnce(Result<(), glib::Error>) + 'static>(path: &str, connection: &gio::DBusConnection, cancellable: Option<&P>, callback: Q) {
    //    unsafe { TODO: call ibus_sys:ibus_input_context_get_input_context_async() }
    //}

    //pub fn new_async<P: IsA<gio::Cancellable>, Q: FnOnce(Result<(), glib::Error>) + 'static>(path: &str, connection: &gio::DBusConnection, cancellable: Option<&P>, callback: Q) {
    //    unsafe { TODO: call ibus_sys:ibus_input_context_new_async() }
    //}
}

pub const NONE_INPUT_CONTEXT: Option<&InputContext> = None;

pub trait InputContextExt: 'static {
    fn cancel_hand_writing(&self, n_strokes: u32);

    fn focus_in(&self);

    fn focus_out(&self);

    fn get_engine(&self) -> Option<EngineDesc>;

    //fn get_engine_async<P: IsA<gio::Cancellable>, Q: FnOnce(Result<(), glib::Error>) + 'static>(&self, timeout_msec: i32, cancellable: Option<&P>, callback: Q);

    fn needs_surrounding_text(&self) -> bool;

    fn process_hand_writing_event(&self, coordinates: f64, coordinates_len: u32);

    fn process_key_event(&self, keyval: u32, keycode: u32, state: u32) -> bool;

    //fn process_key_event_async<P: IsA<gio::Cancellable>, Q: FnOnce(Result<(), glib::Error>) + 'static>(&self, keyval: u32, keycode: u32, state: u32, timeout_msec: i32, cancellable: Option<&P>, callback: Q);

    fn property_activate(&self, prop_name: &str, state: u32);

    fn reset(&self);

    fn set_capabilities(&self, capabilities: u32);

    fn set_client_commit_preedit(&self, client_commit: bool);

    fn set_content_type(&self, purpose: u32, hints: u32);

    fn set_cursor_location(&self, x: i32, y: i32, w: i32, h: i32);

    fn set_cursor_location_relative(&self, x: i32, y: i32, w: i32, h: i32);

    fn set_engine(&self, name: &str);

    fn set_surrounding_text<P: IsA<Text>>(&self, text: &P, cursor_pos: u32, anchor_pos: u32);

    fn connect_commit_text<F: Fn(&Self, &Text) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_cursor_down_lookup_table<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_cursor_up_lookup_table<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_delete_surrounding_text<F: Fn(&Self, i32, u32) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_disabled<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_enabled<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_forward_key_event<F: Fn(&Self, u32, u32, u32) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_hide_auxiliary_text<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_hide_lookup_table<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_hide_preedit_text<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_page_down_lookup_table<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_page_up_lookup_table<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_register_properties<F: Fn(&Self, &PropList) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_show_auxiliary_text<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_show_lookup_table<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_show_preedit_text<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_update_auxiliary_text<F: Fn(&Self, &Text, bool) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_update_lookup_table<F: Fn(&Self, &LookupTable, bool) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_update_preedit_text<F: Fn(&Self, &Text, u32, bool) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_update_preedit_text_with_mode<F: Fn(&Self, &Text, u32, bool, u32) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_update_property<F: Fn(&Self, &Property) + 'static>(&self, f: F) -> SignalHandlerId;
}

impl<O: IsA<InputContext>> InputContextExt for O {
    fn cancel_hand_writing(&self, n_strokes: u32) {
        unsafe {
            ibus_sys::ibus_input_context_cancel_hand_writing(self.as_ref().to_glib_none().0, n_strokes);
        }
    }

    fn focus_in(&self) {
        unsafe {
            ibus_sys::ibus_input_context_focus_in(self.as_ref().to_glib_none().0);
        }
    }

    fn focus_out(&self) {
        unsafe {
            ibus_sys::ibus_input_context_focus_out(self.as_ref().to_glib_none().0);
        }
    }

    fn get_engine(&self) -> Option<EngineDesc> {
        unsafe {
            from_glib_none(ibus_sys::ibus_input_context_get_engine(self.as_ref().to_glib_none().0))
        }
    }

    //fn get_engine_async<P: IsA<gio::Cancellable>, Q: FnOnce(Result<(), glib::Error>) + 'static>(&self, timeout_msec: i32, cancellable: Option<&P>, callback: Q) {
    //    unsafe { TODO: call ibus_sys:ibus_input_context_get_engine_async() }
    //}

    fn needs_surrounding_text(&self) -> bool {
        unsafe {
            from_glib(ibus_sys::ibus_input_context_needs_surrounding_text(self.as_ref().to_glib_none().0))
        }
    }

    fn process_hand_writing_event(&self, coordinates: f64, coordinates_len: u32) {
        unsafe {
            ibus_sys::ibus_input_context_process_hand_writing_event(self.as_ref().to_glib_none().0, coordinates, coordinates_len);
        }
    }

    fn process_key_event(&self, keyval: u32, keycode: u32, state: u32) -> bool {
        unsafe {
            from_glib(ibus_sys::ibus_input_context_process_key_event(self.as_ref().to_glib_none().0, keyval, keycode, state))
        }
    }

    //fn process_key_event_async<P: IsA<gio::Cancellable>, Q: FnOnce(Result<(), glib::Error>) + 'static>(&self, keyval: u32, keycode: u32, state: u32, timeout_msec: i32, cancellable: Option<&P>, callback: Q) {
    //    unsafe { TODO: call ibus_sys:ibus_input_context_process_key_event_async() }
    //}

    fn property_activate(&self, prop_name: &str, state: u32) {
        unsafe {
            ibus_sys::ibus_input_context_property_activate(self.as_ref().to_glib_none().0, prop_name.to_glib_none().0, state);
        }
    }

    fn reset(&self) {
        unsafe {
            ibus_sys::ibus_input_context_reset(self.as_ref().to_glib_none().0);
        }
    }

    fn set_capabilities(&self, capabilities: u32) {
        unsafe {
            ibus_sys::ibus_input_context_set_capabilities(self.as_ref().to_glib_none().0, capabilities);
        }
    }

    fn set_client_commit_preedit(&self, client_commit: bool) {
        unsafe {
            ibus_sys::ibus_input_context_set_client_commit_preedit(self.as_ref().to_glib_none().0, client_commit.to_glib());
        }
    }

    fn set_content_type(&self, purpose: u32, hints: u32) {
        unsafe {
            ibus_sys::ibus_input_context_set_content_type(self.as_ref().to_glib_none().0, purpose, hints);
        }
    }

    fn set_cursor_location(&self, x: i32, y: i32, w: i32, h: i32) {
        unsafe {
            ibus_sys::ibus_input_context_set_cursor_location(self.as_ref().to_glib_none().0, x, y, w, h);
        }
    }

    fn set_cursor_location_relative(&self, x: i32, y: i32, w: i32, h: i32) {
        unsafe {
            ibus_sys::ibus_input_context_set_cursor_location_relative(self.as_ref().to_glib_none().0, x, y, w, h);
        }
    }

    fn set_engine(&self, name: &str) {
        unsafe {
            ibus_sys::ibus_input_context_set_engine(self.as_ref().to_glib_none().0, name.to_glib_none().0);
        }
    }

    fn set_surrounding_text<P: IsA<Text>>(&self, text: &P, cursor_pos: u32, anchor_pos: u32) {
        unsafe {
            ibus_sys::ibus_input_context_set_surrounding_text(self.as_ref().to_glib_none().0, text.as_ref().to_glib_none().0, cursor_pos, anchor_pos);
        }
    }

    fn connect_commit_text<F: Fn(&Self, &Text) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn commit_text_trampoline<P, F: Fn(&P, &Text) + 'static>(this: *mut ibus_sys::IBusInputContext, text: *mut ibus_sys::IBusText, f: glib_sys::gpointer)
            where P: IsA<InputContext>
        {
            let f: &F = &*(f as *const F);
            f(&InputContext::from_glib_borrow(this).unsafe_cast_ref(), &from_glib_borrow(text))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"commit-text\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(commit_text_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_cursor_down_lookup_table<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn cursor_down_lookup_table_trampoline<P, F: Fn(&P) + 'static>(this: *mut ibus_sys::IBusInputContext, f: glib_sys::gpointer)
            where P: IsA<InputContext>
        {
            let f: &F = &*(f as *const F);
            f(&InputContext::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"cursor-down-lookup-table\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(cursor_down_lookup_table_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_cursor_up_lookup_table<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn cursor_up_lookup_table_trampoline<P, F: Fn(&P) + 'static>(this: *mut ibus_sys::IBusInputContext, f: glib_sys::gpointer)
            where P: IsA<InputContext>
        {
            let f: &F = &*(f as *const F);
            f(&InputContext::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"cursor-up-lookup-table\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(cursor_up_lookup_table_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_delete_surrounding_text<F: Fn(&Self, i32, u32) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn delete_surrounding_text_trampoline<P, F: Fn(&P, i32, u32) + 'static>(this: *mut ibus_sys::IBusInputContext, offset: libc::c_int, n_chars: libc::c_uint, f: glib_sys::gpointer)
            where P: IsA<InputContext>
        {
            let f: &F = &*(f as *const F);
            f(&InputContext::from_glib_borrow(this).unsafe_cast_ref(), offset, n_chars)
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"delete-surrounding-text\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(delete_surrounding_text_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_disabled<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn disabled_trampoline<P, F: Fn(&P) + 'static>(this: *mut ibus_sys::IBusInputContext, f: glib_sys::gpointer)
            where P: IsA<InputContext>
        {
            let f: &F = &*(f as *const F);
            f(&InputContext::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"disabled\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(disabled_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_enabled<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn enabled_trampoline<P, F: Fn(&P) + 'static>(this: *mut ibus_sys::IBusInputContext, f: glib_sys::gpointer)
            where P: IsA<InputContext>
        {
            let f: &F = &*(f as *const F);
            f(&InputContext::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"enabled\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(enabled_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_forward_key_event<F: Fn(&Self, u32, u32, u32) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn forward_key_event_trampoline<P, F: Fn(&P, u32, u32, u32) + 'static>(this: *mut ibus_sys::IBusInputContext, keyval: libc::c_uint, keycode: libc::c_uint, modifiers: libc::c_uint, f: glib_sys::gpointer)
            where P: IsA<InputContext>
        {
            let f: &F = &*(f as *const F);
            f(&InputContext::from_glib_borrow(this).unsafe_cast_ref(), keyval, keycode, modifiers)
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"forward-key-event\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(forward_key_event_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_hide_auxiliary_text<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn hide_auxiliary_text_trampoline<P, F: Fn(&P) + 'static>(this: *mut ibus_sys::IBusInputContext, f: glib_sys::gpointer)
            where P: IsA<InputContext>
        {
            let f: &F = &*(f as *const F);
            f(&InputContext::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"hide-auxiliary-text\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(hide_auxiliary_text_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_hide_lookup_table<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn hide_lookup_table_trampoline<P, F: Fn(&P) + 'static>(this: *mut ibus_sys::IBusInputContext, f: glib_sys::gpointer)
            where P: IsA<InputContext>
        {
            let f: &F = &*(f as *const F);
            f(&InputContext::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"hide-lookup-table\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(hide_lookup_table_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_hide_preedit_text<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn hide_preedit_text_trampoline<P, F: Fn(&P) + 'static>(this: *mut ibus_sys::IBusInputContext, f: glib_sys::gpointer)
            where P: IsA<InputContext>
        {
            let f: &F = &*(f as *const F);
            f(&InputContext::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"hide-preedit-text\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(hide_preedit_text_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_page_down_lookup_table<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn page_down_lookup_table_trampoline<P, F: Fn(&P) + 'static>(this: *mut ibus_sys::IBusInputContext, f: glib_sys::gpointer)
            where P: IsA<InputContext>
        {
            let f: &F = &*(f as *const F);
            f(&InputContext::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"page-down-lookup-table\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(page_down_lookup_table_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_page_up_lookup_table<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn page_up_lookup_table_trampoline<P, F: Fn(&P) + 'static>(this: *mut ibus_sys::IBusInputContext, f: glib_sys::gpointer)
            where P: IsA<InputContext>
        {
            let f: &F = &*(f as *const F);
            f(&InputContext::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"page-up-lookup-table\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(page_up_lookup_table_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_register_properties<F: Fn(&Self, &PropList) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn register_properties_trampoline<P, F: Fn(&P, &PropList) + 'static>(this: *mut ibus_sys::IBusInputContext, props: *mut ibus_sys::IBusPropList, f: glib_sys::gpointer)
            where P: IsA<InputContext>
        {
            let f: &F = &*(f as *const F);
            f(&InputContext::from_glib_borrow(this).unsafe_cast_ref(), &from_glib_borrow(props))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"register-properties\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(register_properties_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_show_auxiliary_text<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn show_auxiliary_text_trampoline<P, F: Fn(&P) + 'static>(this: *mut ibus_sys::IBusInputContext, f: glib_sys::gpointer)
            where P: IsA<InputContext>
        {
            let f: &F = &*(f as *const F);
            f(&InputContext::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"show-auxiliary-text\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(show_auxiliary_text_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_show_lookup_table<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn show_lookup_table_trampoline<P, F: Fn(&P) + 'static>(this: *mut ibus_sys::IBusInputContext, f: glib_sys::gpointer)
            where P: IsA<InputContext>
        {
            let f: &F = &*(f as *const F);
            f(&InputContext::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"show-lookup-table\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(show_lookup_table_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_show_preedit_text<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn show_preedit_text_trampoline<P, F: Fn(&P) + 'static>(this: *mut ibus_sys::IBusInputContext, f: glib_sys::gpointer)
            where P: IsA<InputContext>
        {
            let f: &F = &*(f as *const F);
            f(&InputContext::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"show-preedit-text\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(show_preedit_text_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_update_auxiliary_text<F: Fn(&Self, &Text, bool) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn update_auxiliary_text_trampoline<P, F: Fn(&P, &Text, bool) + 'static>(this: *mut ibus_sys::IBusInputContext, text: *mut ibus_sys::IBusText, visible: glib_sys::gboolean, f: glib_sys::gpointer)
            where P: IsA<InputContext>
        {
            let f: &F = &*(f as *const F);
            f(&InputContext::from_glib_borrow(this).unsafe_cast_ref(), &from_glib_borrow(text), from_glib(visible))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"update-auxiliary-text\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(update_auxiliary_text_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_update_lookup_table<F: Fn(&Self, &LookupTable, bool) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn update_lookup_table_trampoline<P, F: Fn(&P, &LookupTable, bool) + 'static>(this: *mut ibus_sys::IBusInputContext, table: *mut ibus_sys::IBusLookupTable, visible: glib_sys::gboolean, f: glib_sys::gpointer)
            where P: IsA<InputContext>
        {
            let f: &F = &*(f as *const F);
            f(&InputContext::from_glib_borrow(this).unsafe_cast_ref(), &from_glib_borrow(table), from_glib(visible))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"update-lookup-table\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(update_lookup_table_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_update_preedit_text<F: Fn(&Self, &Text, u32, bool) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn update_preedit_text_trampoline<P, F: Fn(&P, &Text, u32, bool) + 'static>(this: *mut ibus_sys::IBusInputContext, text: *mut ibus_sys::IBusText, cursor_pos: libc::c_uint, visible: glib_sys::gboolean, f: glib_sys::gpointer)
            where P: IsA<InputContext>
        {
            let f: &F = &*(f as *const F);
            f(&InputContext::from_glib_borrow(this).unsafe_cast_ref(), &from_glib_borrow(text), cursor_pos, from_glib(visible))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"update-preedit-text\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(update_preedit_text_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_update_preedit_text_with_mode<F: Fn(&Self, &Text, u32, bool, u32) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn update_preedit_text_with_mode_trampoline<P, F: Fn(&P, &Text, u32, bool, u32) + 'static>(this: *mut ibus_sys::IBusInputContext, text: *mut ibus_sys::IBusText, cursor_pos: libc::c_uint, visible: glib_sys::gboolean, mode: libc::c_uint, f: glib_sys::gpointer)
            where P: IsA<InputContext>
        {
            let f: &F = &*(f as *const F);
            f(&InputContext::from_glib_borrow(this).unsafe_cast_ref(), &from_glib_borrow(text), cursor_pos, from_glib(visible), mode)
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"update-preedit-text-with-mode\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(update_preedit_text_with_mode_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_update_property<F: Fn(&Self, &Property) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn update_property_trampoline<P, F: Fn(&P, &Property) + 'static>(this: *mut ibus_sys::IBusInputContext, prop: *mut ibus_sys::IBusProperty, f: glib_sys::gpointer)
            where P: IsA<InputContext>
        {
            let f: &F = &*(f as *const F);
            f(&InputContext::from_glib_borrow(this).unsafe_cast_ref(), &from_glib_borrow(prop))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"update-property\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(update_property_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }
}

impl fmt::Display for InputContext {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "InputContext")
    }
}
